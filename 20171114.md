minidump学习
dll学习，解决问题

MiniDumpWriteDump


## 动态链接库


动态链接库是一个模块，它包含一些函数和数据，这些函数和数据可以被其它模块（程序或者动态链接库）所使用。

当它被另一个动态链接库调用的时候，可以认为动态链接库可以嵌套调用。

一个动态链接库可以定义两种函数：导出函数和内部函数。

导出函数的用处是被其它模块调用，当然也可以被定义该函数的动态链接库中的函数调用。

内部函数一般只是被定义该函数的动态链接库中的函数使用。

尽管动态链接库可以导出数据，但是通常它的数据仅仅被自己的函数使用。

然而，你无法阻止其他模块对那个数据地址进行读取。


动态链接库提供了一种方法，该方法可以将程序模块化，因此动态链接库可以很容易的被更新和重复使用。

当多个应用程序同时使用相同的功能时，动态链接库可以帮助减少内存开销。

因为，即使每个应用程序会拷贝该DLL中数据的副本，但是该DLL源代码本身是共享的。

API是作为一系列DLL来实现的，所以使用了Windows的API的任何进程都使用了动态链接方式。

## 使用动态链接库

### 创建一个简单的动态链接库

下面的例子是创建一个简单的DLL所需要的源代码，Myputs.dll。它定义了一个简单的字符串打印函数：myPuts。

Myputs DLL没有定义进入点函数，因为它连接到C运行时库并且它自己没有需要执行的初始化或者清理函数。

要创建DLL，按照以下文档的指导完成， 文档包含在你的开发工具中。

``` C++
// The myPuts function writes a null-terminated string to
// the standard output device.
 
// The export mechanism used here is the __declspec(export)
// method supported by Microsoft Visual Studio, but any
// other export method supported by your development
// environment may be substituted.
 
 
#include <windows.h>
 
#define EOF (-1)
 
#ifdef __cplusplus    // If used by C++ code, 
extern "C" {          // we need to export the C interface
#endif
 
__declspec(dllexport) int __cdecl myPuts(LPWSTR lpszMsg)
{
    DWORD cchWritten;
    HANDLE hConout;
    BOOL fRet;
 
    // Get a handle to the console output device.

    hConout = CreateFileW(L"CONOUT$",
                         GENERIC_WRITE,
                         FILE_SHARE_WRITE,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (INVALID_HANDLE_VALUE == hConout)
        return EOF;
 
    // Write a null-terminated string to the console output device.
 
    while (*lpszMsg != L'\0')
    {
        fRet = WriteConsole(hConout, lpszMsg, 1, &cchWritten, NULL);
        if( (FALSE == fRet) || (1 != cchWritten) )
            return EOF;
        lpszMsg++;
    }
    return 1;
}
 
#ifdef __cplusplus
}
#endif
```


### 使用加载时动态链接

当你创建一个DLL之后，你可以在一个应用程序中使用该DLL定义的函数。下面是一个简单的控制台应用程序，

该应用程序使用了myPuts.dll导出的myPuts函数。

因为该例子使用显示方式调用myPuts.dll， 应用程序的该DLL模块必须与导入库（myPuts.lib）链接在一起。

要获取更多关于创建DLL的信息，参看你的开发工具中的说明文档。

``` C++
#include <windows.h> 

extern "C" int __cdecl myPuts(LPWSTR);   // a function from a DLL

int main(VOID) 
{ 
    int Ret = 1;

    Ret = myPuts(L"Message sent to the DLL function\n"); 
    return Ret;
}
```


### 使用运行时动态链接

对于同一个DLL，你可以使用两种方式加载，加载时和运行时。

下面的例子使用LoadLibrary这个函数来获取myPuts.dll的句柄。

如果LoadLibrary函数成功，程序使用返回的句柄作为GetProcAddress函数的参数，来获取DLL中的myPuts函数的地址。

调用myPuts.dll中的函数之后，程序需要调用FreeLibrary函数来释放该myPuts.dll。

因为程序使用运行时动态链接，链接该myPuts模块时不需要使用该myPuts.dll的导入库。

这个例子展示了运行时和加载时动态链接的不同。如果DLL不可用，那么使用加载时动态链接的程序必须终止进程。

然而，运行时动态加载示例可以提示一个错误而不必终止进程。

``` C++
// A simple program that uses LoadLibrary and 
// GetProcAddress to access myPuts from Myputs.dll. 
 
#include <windows.h> 
#include <stdio.h> 
 
typedef int (__cdecl *MYPROC)(LPWSTR); 
 
int main( void ) 
{ 
    HINSTANCE hinstLib; 
    MYPROC ProcAdd; 
    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; 
 
    // Get a handle to the DLL module.
 
    hinstLib = LoadLibrary(TEXT("MyPuts.dll")); 
 
    // If the handle is valid, try to get the function address.
 
    if (hinstLib != NULL) 
    { 
        ProcAdd = (MYPROC) GetProcAddress(hinstLib, "myPuts"); 
 
        // If the function address is valid, call the function.
 
        if (NULL != ProcAdd) 
        {
            fRunTimeLinkSuccess = TRUE;
            (ProcAdd) (L"Message sent to the DLL function\n"); 
        }
        // Free the DLL module.
 
        fFreeResult = FreeLibrary(hinstLib); 
    } 

    // If unable to call the DLL function, use an alternative.
    if (! fRunTimeLinkSuccess) 
        printf("Message printed from executable\n"); 

    return 0;

}
```
















