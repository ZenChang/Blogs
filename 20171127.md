fPort 工具可以查看端口号

学习c语言循环相关的知识点

使用pLog时可以使用LOGE_IF这样的话可以，使用DLL注入方式将其更改打印方式

实验证明：只需要用LOGE_IF(condition)即可，然后通过WriteProcessMemory将condition的地址改为0即可。

```
target ... : prerequisites ...

    recipe
    
    ...
    
    ...
```

一个处方是make执行的一个动作。一个处方可能会有超过1个命令，或者在同一行，或者在各自行。

请注意：你需要在每个处方行的开始处放置一个tab字符。这可以默默地捕捉你的粗心。

如果你喜欢用一个区别于tab的字符作为处方的前缀，你可以设置.RECIPEPREFIX变量,将其改为其他字符。

通常一个处方伴随着一些prerequisite，并且当prerequisite有任何更改时，服务于创建一个目标文件。

然而，指定目标的处方的规则不需要有先决条件。例如，包含与目标clean相关的delete命令的规则

不需要有先决条件。

一个规则，解释了如何以及何时重新编译特定文件，这些特定文件是特定规则的目标。

make在先决条件的基础上执行这个处方，用于生成或者更新目标。

一个规则也可以解释如何以及何时执行一个动作。


一个makefile除了规则之外可能包含其他的文本，但是一个简单的makefile仅仅需要特定的规则。

规则可能会看起来比展示在这个模板里面的稍微更加复杂一些，但是所有的makefile都或多或少适合这个模式。

## 一个简单的makefile

这里是一个直接了当的makefile，这个makefile描述了一个叫做edit的可执行文件

如何依赖于8个目标文件，而这8个目标文件反过来又依赖于8个C源文件和3个头文件。

在这个例子中，所有的C文件包含defs.h，但是只有那些定义了编辑命令的文件包含了command.h，

并且，仅仅改变编辑器缓存的低级别文件包含了buffer.h。

edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o

\t cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

main.o : main.c defs.h

\t cc -c main.c

kbd.o : kbd.c defs.h command.h

\t cc -c kbd.c

command.o : command.c defs.h command.h

\t cc -c command.c

display.o : display.c defs.h buffer.h

\t cc -c display.c

insert.o : insert.c defs.h buffer.h

\t cc -c insert.c

search.o : search.c defs.h buffer.h

\t cc -c search.c

files.o : files.c defs.h buffer.h command.h

\t cc -c files.c

utils.o : utils.c defs.h

\t cc -c utils.c

clean :

\t rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

我们使用/将每一个长行分割为2行;这如同使用一个长行，但是易读性好。

要使用这个makefile产生一个叫做edit的可执行文件，输入：make

要使用这个makefile从目录中删除可执行文件以及所有的目标文件，键入：make clean

在这个示例makefile中，目标包含可执行文件edit，以及目标文件main.o和kbd.o。

先决条件是文件比如`main.c`和`defs.h`。事实上，每个`.o`文件既是一个目标也是一个先决条件。

处方包含`cc -c main.c`以及`cc -c kbd.c`。

当一个目标是一个文件，它需要被重新编译或者重新连接，如果它的任何先决条件有更改。

另外，任何自动生成的先决条件应该被先更新。在这个例子中，**edit**依赖于8个目标文件。

目标文件main.o依赖于




















MyPluginDemo.cpp
``` C++
#include "stdafx.h"
#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
using namespace std;

DWORD GetProcessId(LPCSTR lpszProcessName) 
{
    // 创建进程快照句柄  
    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);  
    DWORD dwPid = NULL;  
    PROCESSENTRY32 ProcessEntry;  
    // 查找第一个进程  
    ProcessEntry.dwSize = sizeof(PROCESSENTRY32);  
    Process32First(hProcessSnap, &ProcessEntry);  
    // 遍历进程获取 PID  
    do 
    { 
        if(!stricmp(ProcessEntry.szExeFile, lpszProcessName)) 
        {  
            dwPid = ProcessEntry.th32ProcessID;  
            break;  
        }  
    } 
    while(Process32Next(hProcessSnap, &ProcessEntry));  
    // 清理现场  
    if(!dwPid) 
    {     
        return false;  
    } 
    CloseHandle(hProcessSnap);  
    return dwPid;  
}

int main(int argc, char ** argv)
{
    // 线程栈大小  
    const DWORD dwThreadSize = 1024;
    // 获取指定映像的 PID  
    DWORD dwProcessId = false;  
    dwProcessId = GetProcessId("VisionMaster.exe");  
    if (!dwProcessId){  
        return 0;
    }  
    // 定义远程进程句柄并打开该进程  
    HANDLE hRemoteProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);  
    if (!hRemoteProcess)
    {
        return 0;
    }

    LPVOID pFunc = LoadLibrary;

    LPVOID pRemoteParam = VirtualAllocEx(hRemoteProcess, NULL, strlen("MyPlugin.dll") + 1, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);  
    if (!pRemoteParam) 
    {
        return 0;
    }

    BOOL bWrite = WriteProcessMemory(hRemoteProcess, (LPVOID)pRemoteParam, "MyPlugin.dll", strlen("MyPlugin.dll") + 1, 0);
    if (!bWrite)
    {
        return 0;
    }

    HANDLE hRemoteThread = CreateRemoteThread(hRemoteProcess, NULL, 0, (LPTHREAD_START_ROUTINE)(pFunc), pRemoteParam, 0, NULL);  
    if (!hRemoteThread) 
    {
        return 0;
    }

    getchar();
    return 0;
}

```

MyPlugin.cpp

``` C++
// dllmain.cpp : Defines the entry point for the DLL application.
#include "stdafx.h"
#include <Windows.h>

HMODULE g_hModule                       = NULL;
void *(* zmq_ctx_new) (void)            = NULL;
void (__stdcall * IMVS_SetMaxSeverity)(const unsigned int nMaxSeverity) = NULL;

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        {
            OutputDebugString("成功加载MyPlugin.dll");

            g_hModule = LoadLibraryEx("./PublicFile/x86/iMVS-6000SDK4Server.dll", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
            if (NULL == g_hModule)
            {
                return FALSE;
            }
            IMVS_SetMaxSeverity = (void (__stdcall *)(const unsigned int))GetProcAddress(g_hModule,"IMVS_SetMaxSeverity");
            if (NULL == IMVS_SetMaxSeverity)
            {
                return FALSE;
            }

            OutputDebugString("成功加载iMVS-6000SDK4Server.dll");

            IMVS_SetMaxSeverity(0);

            OutputDebugString("成功设置日志打印级别");
        }
        break;
    case DLL_THREAD_ATTACH:
        {
        }
        break;
    case DLL_THREAD_DETACH:
        {
        }
        break;
    case DLL_PROCESS_DETACH:
        {
        }
        break;
    }
    return TRUE;
}
```


