
## 算法平台2.1中的读取并发线程锁&进程锁的实现

### 案例简述

算法平台2.1有三个特点：一，进程多（可达到30个以上）；二，每个进程的线程多（可达到10个以上）；三，多进程与多线程之间数据交互频繁（分布式数据通信）。

如此高并发的数据通信使得数据的安全性尤为重要，一个直观的解决办法就是将数据增加线程锁以及进程锁。

在算法平台2.0中采用的线程锁是关键代码段，采用的进程锁是内核对象互斥体。

但是这两种锁都有一个重要的缺陷，那就是影响并发的高效性，使得并发变成了一个轮询的同步效果而已。

亦即：

    当一个线程(或进程)正在写入或读取数据时，其他任何线程(或进程)不能写入或读取数据

然而实际上，我们要在保证数据安全的前提下实现真正的读取并发（注意：非写入并发）。

比如：

    1) 当一个（或多个）线程(或进程)正在写入数据时，其他任何线程(或进程)不能写入数据
    2) 当一个（或多个）线程(或进程)正在写入数据时，其他任何线程(或进程)不能读取数据
    3) 当一个（或多个）线程(或进程)正在读取数据时，其他任何线程(或进程)不能写入数据
    4) 当一个（或多个）线程(或进程)正在读取数据时，其他任何线程(或进程)能够读取数据（*）

### 案例分析和解决过程

#### 案例分析

算法平台示例：


将读取并发线程锁&进程锁效果再次声明一下：

    1) 当一个（或多个）线程(或进程)正在写入数据时，其他任何线程(或进程)不能写入数据
    2) 当一个（或多个）线程(或进程)正在写入数据时，其他任何线程(或进程)不能读取数据
    3) 当一个（或多个）线程(或进程)正在读取数据时，其他任何线程(或进程)不能写入数据
    4) 当一个（或多个）线程(或进程)正在读取数据时，其他任何线程(或进程)能够读取数据（*）

要想达此种效果，我们就不能简单地使用关键代码段或者互斥进程锁了。

我们需要在此基础上增加一些判断条件，将所有读写情况归纳为上述4种情况。

当遇到前三种情况时，我们必须让线程（或进程）等待，待数据安全后方可获取读取权限。

当遇到最后一种情况时，线程（或进程）无须等待，直接获取读取权限。

要达到这种等待效果，我们使用内核对象信号量实现。

#### 解决过程

需求整理：
！[我的图片](D:\\GITHUBFILES\\codes\\MyLockDemo\\资源文件\\进程锁用例图.bmp)


类设计：


功能实现：

读取开始

读取结束

写入开始

写入结束


示例展示：



### 经验总结，预防措施和建议

### 从本文可导出的检查项

    1. 进程锁的实现为原创，使用了较多的assert，并未对异常做过多保护，后续完善。
    2. 后续可以将线程锁和进程锁合并为一个类，以构造函数的输入参数作为区分。















