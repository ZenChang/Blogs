
## 算法平台2.1中的读取并发线程&进程锁的实现

### 案例简述

算法平台2.1有三个特点：一，进程多（可达到30个以上）；二，每个进程的线程多（可达到10个以上）；三，多进程与多线程之间数据交互频繁（分布式数据通信）。

如此高并发的数据通信使得数据的安全性尤为重要，一个直观的解决办法就是将数据增加线程锁以及进程锁。

在算法平台2.0中采用的线程锁是关键代码段，采用的进程锁是内核对象互斥体。

但是这两种锁都有一个重要的缺陷，那就是影响并发的高效性，使得并发变成了一个轮询的同步效果而已。

即：

    当一个线程(或进程)正在写入或读取数据时，其他任何线程(或进程)不能写入或读取数据

然而实际上，我们要在保证数据安全的前提下实现真正的读取并发（注意：非写入并发）。

比如：

    1) 当一个线程(或进程)正在写入数据时，其他任何线程(或进程)不能写入数据
    2) 当一个线程(或进程)正在写入数据时，其他任何线程(或进程)不能读取数据
    3) 当一个线程(或进程)正在读取数据时，其他任何线程(或进程)不能写入数据
    4) 当一个线程(或进程)正在读取数据时，其他任何线程(或进程)能够读取数据（*）

### 案例分析和解决过程

### 经验总结，预防措施和建议

### 从本文可导出的检查项















